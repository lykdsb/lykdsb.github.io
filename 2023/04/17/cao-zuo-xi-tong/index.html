<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="Laiyikou">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2023/04/17/cao-zuo-xi-tong/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    <meta property="og:type" content="article">
    <meta property="og:title" content="操作系统">
    <meta property="og:description" content="Hexo Theme Redefine">
    <meta property="og:url" content="http://example.com2023/04/17/cao-zuo-xi-tong/">
    <meta property="og:image" content="/images/redefine-logo.svg">
    <meta property="og:site_name" content="Laiyikou&#39;s Blog">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="操作系统">
    <meta name="twitter:description" content="Hexo Theme Redefine">
    <meta name="twitter:image" content="/images/redefine-logo.svg">
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/images/redefine-logo.svg">
    
    <title>
        
            操作系统 -
        
        Laiyikou&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/assets/fonts.css">

    
    
    
    
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/redefine-avatar.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"Laiyikou's Blog","custom_font":{"enable":false,"font_family":null,"font_url":null}},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_block":{"copy":true,"style":"mac","custom_font":{"enable":false,"font_family":null,"font_url":null}},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"1.1.3","friend_links":{"columns":2},"home_article":{"date_format":"auto","category":{"enable":true,"limit":3},"tag":{"enable":true,"limit":3}}};
    REDEFINE.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
    
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="menu-wrapper">
    
    <div class="menu-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Laiyikou&#39;s Blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        归档
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/categories"  >
                                    
                                        
                                            <i class="fa-regular fa-inbox"></i>
                                        
                                        分类
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/tags"  >
                                    
                                        
                                            <i class="fa-regular fa-tag"></i>
                                        
                                        标签
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="menu-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                归档
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/categories"  >
                             
                                
                                    <i class="fa-regular fa-inbox"></i>
                                
                                分类
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/tags"  >
                             
                                
                                    <i class="fa-regular fa-tag"></i>
                                
                                标签
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">操作系统</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/redefine-avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Laiyikou</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2023-04-17 21:50:33</span>
        <span class="mobile">2023-04-17 21:50</span>
        <span class="hover-info">创建时间</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="pc">2023-04-17 21:52:31</span>
            <span class="mobile">2023-04-17 21:52</span>
            <span class="hover-info">更新时间</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-file-word"></i>&nbsp;<span>6.1k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>21 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><h4 id="什么是中断？"><a href="#什么是中断？" class="headerlink" title="什么是中断？"></a>什么是中断？</h4><p>操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求</p>
<h4 id="什么是软中断？"><a href="#什么是软中断？" class="headerlink" title="什么是软中断？"></a>什么是软中断？</h4><p>由于CPU在处理一个中断的时候不能够同时处理另一个。</p>
<p>那 Linux 系统<strong>为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」</strong>。</p>
<ul>
<li><strong>上半部用来快速处理中断</strong>，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。</li>
<li><strong>下半部用来延迟处理上半部未完成的工作</strong>，一般以「内核线程」的方式运行。</li>
</ul>
<p>假设点了两份外卖，由于第一个配送员长时间跟我通话，则导致第二位配送员无法拨通我的电话，其实当我接到第一位配送员的电话，可以告诉配送员说我现在下楼，剩下的事情，等我们见面再说（上半部），然后就可以挂断电话，到楼下后，在拿外卖，以及跟配送员说其他的事情（下半部）。</p>
<p>这样，第一位配送员就不会占用我手机太多时间，当第二位配送员正好过来时，会有很大几率拨通我的电话。</p>
<p>硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行</p>
<h4 id="软中断有哪些类型？"><a href="#软中断有哪些类型？" class="headerlink" title="软中断有哪些类型？"></a>软中断有哪些类型？</h4><p><code>NET_RX</code>:网络接受中断</p>
<p><code>NET_TX</code>：网络发送中断</p>
<p><code>TIMER</code>：定时中断</p>
<p>…</p>
<h4 id="如果软中断导致CPU占用率过高？"><a href="#如果软中断导致CPU占用率过高？" class="headerlink" title="如果软中断导致CPU占用率过高？"></a>如果软中断导致CPU占用率过高？</h4><p>在<code>/proc/softirqs</code>中可以看到软中断情况</p>
<ol>
<li>发现<code>NET_RX</code>变化速率很快</li>
<li>使用<code>tcpdump</code>进行抓包</li>
<li>如果有大量非法地址可以考虑防火墙拦截</li>
</ol>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><h4 id="进程与线程的区别是什么？"><a href="#进程与线程的区别是什么？" class="headerlink" title="进程与线程的区别是什么？"></a>进程与线程的区别是什么？</h4><ul>
<li>进程时分配资源的最小单位</li>
<li>线程时CPU调度的最小单位</li>
<li>同一进程中的不同线程可以直接通信</li>
<li>进程的开销要远远大于线程的开销</li>
</ul>
<h4 id="进程有哪些状态？"><a href="#进程有哪些状态？" class="headerlink" title="进程有哪些状态？"></a>进程有哪些状态？</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" alt="img"></p>
<h4 id="进程有哪些通信方式？"><a href="#进程有哪些通信方式？" class="headerlink" title="进程有哪些通信方式？"></a>进程有哪些通信方式？</h4><ul>
<li>管道：只能在父子进程或者兄弟进程中使用</li>
<li>FIFO：去除了上面的限制</li>
<li>消息队列<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
</ul>
</li>
<li>共享内存</li>
<li>Socket</li>
<li>信号量</li>
</ul>
<h4 id="多进程和多线程之间的区别是什么？"><a href="#多进程和多线程之间的区别是什么？" class="headerlink" title="多进程和多线程之间的区别是什么？"></a>多进程和多线程之间的区别是什么？</h4><ul>
<li>多进程更耗资源。每个进程都有独立的资源，线程间共享资源</li>
<li>多进程更安全。线程间共享内存，进程间通信更麻烦</li>
<li>多进程更稳定。一个进程崩溃了不一会影响其他进程。一个线程崩溃了可能会使整个进程崩溃</li>
</ul>
<h4 id="为什么chrome浏览器很多地方都使用进程？"><a href="#为什么chrome浏览器很多地方都使用进程？" class="headerlink" title="为什么chrome浏览器很多地方都使用进程？"></a>为什么chrome浏览器很多地方都使用进程？</h4><ul>
<li><p>速度更快</p>
<p>当一个浏览器存在更多的渲染任务的时候，多进程的并行化程度往往更高。因为互不相关的网页渲染过程彼此独立，减少了不必要的 CPU 争用，整体性能可能反而会更高。</p>
</li>
<li><p>安全性</p>
<p>进程间没有共享的内存，因此隔离程度更高，一个Tab有病毒不容易影响到另一个</p>
</li>
<li><p>可靠性</p>
<p>每个tab使用一个进程，一个tab的快慢或者崩溃不会影响其他tab。而每个tab使用一个线程，当一个tab崩溃了就会影响所有tab，尤其是开启了很多tab，继续开tab会很慢。</p>
</li>
</ul>
<h4 id="使用多进程的缺点有什么？"><a href="#使用多进程的缺点有什么？" class="headerlink" title="使用多进程的缺点有什么？"></a>使用多进程的缺点有什么？</h4><ol>
<li>当开启的页面过多，太多的进程会导致消耗很多资源</li>
<li>进程启动比线程慢</li>
</ol>
<p>但是现在设备内存已经不像二十年前了，不需要太计较内存大小，而且进程启动方面也可以优化，因此浏览器使用多进程已经是大势所趋</p>
<h4 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h4><h4 id="同步和异步有什么区别？"><a href="#同步和异步有什么区别？" class="headerlink" title="同步和异步有什么区别？"></a>同步和异步有什么区别？</h4><h4 id="进程的调度方式有哪些？"><a href="#进程的调度方式有哪些？" class="headerlink" title="进程的调度方式有哪些？"></a>进程的调度方式有哪些？</h4><ul>
<li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="必要条件是什么？"><a href="#必要条件是什么？" class="headerlink" title="必要条件是什么？"></a>必要条件是什么？</h4><ul>
<li>互斥</li>
<li>持有并等待</li>
<li>不可抢夺</li>
<li>环路等待</li>
</ul>
<h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><ul>
<li>鸵鸟政策：不管</li>
<li>死锁预防：破坏四个条件从根本上杜绝</li>
<li>死锁检测与死锁恢复：通过dfs检测成环，然后：<ul>
<li>抢占</li>
<li>回滚</li>
<li>杀死线程</li>
</ul>
</li>
<li>死锁避免：使用银行家算法，在分配资源的时候检测是否可能发生死锁</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="为什么要有虚拟内存？"><a href="#为什么要有虚拟内存？" class="headerlink" title="为什么要有虚拟内存？"></a>为什么要有虚拟内存？</h4><ol>
<li>如果直接使用物理内存，那么进程能够直接访问到物理内存，这样会导致进程能够对于计算机有一些破坏性的操作<ol>
<li>访问隐私数据</li>
<li>破坏操作系统</li>
</ol>
</li>
<li>不利于多个进程的运行。比如说几个进程容易写到对方的存储空间中，这个时候我们就需要虚拟地址将这些进程的存储空间隔离开</li>
</ol>
<h4 id="如何进行虚拟内存和物理内存之间的转换？"><a href="#如何进行虚拟内存和物理内存之间的转换？" class="headerlink" title="如何进行虚拟内存和物理内存之间的转换？"></a>如何进行虚拟内存和物理内存之间的转换？</h4><p>使用内存管理单元MMU进行</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com//mysql/other/72ab76ba697e470b8ceb14d5fc5688d9.png" alt="img"></p>
<h4 id="为什么要使用内存分段？"><a href="#为什么要使用内存分段？" class="headerlink" title="为什么要使用内存分段？"></a>为什么要使用内存分段？</h4><p>因为进程在内存中是这样存储的（代码+堆+栈），如果我们将这三个部分放到一起，由于堆和栈都是要增长的，所以我们只能将其放在存储空间的两端向中间自然增长，这样就导致存储空间的内部存在大量的内部碎片。</p>
<p>如果我们能够将堆、栈、代码根据其逻辑上的不同分开存放，就能够避免这种内部碎片的出现。</p>
<h4 id="内存分段有什么缺点？"><a href="#内存分段有什么缺点？" class="headerlink" title="内存分段有什么缺点？"></a>内存分段有什么缺点？</h4><p>虽然内存分段解决了内部碎片的问题，但是仍然还有外部碎片的问题。比如说有很多小的空间没有办法分配比较大的内存空间</p>
<p>出现这种问题的根本原因在于：<strong>不同分段的长度是不一样的</strong></p>
<p><strong><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com//mysql/other/6142bc3c917e4a6298bdb62936e0d332.png" alt="img"></strong></p>
<p>要解决外部碎片的问题可以使用内存交换的方法，将占用比较大的内存区域换到磁盘中，进行分配之后再换回来（比如说先将音乐占用的交换到磁盘中，就可以分配256MB的新的内存，分配完之后将音乐的部分交换回来，这样就都分配成功了）。但是这样频繁的交换会导致机器的卡顿（由于读写磁盘比较慢）</p>
<p><strong>所以我们需要使用内存分页的手段</strong></p>
<h4 id="什么是内存分页？"><a href="#什么是内存分页？" class="headerlink" title="什么是内存分页？"></a>什么是内存分页？</h4><p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <code>4KB</code>。</p>
<p>虚拟地址和物理地址之间使用页表来进行映射</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com//mysql/other/08a8e315fedc4a858060db5cb4a654af.png" alt="img"></p>
<p>由于分页是紧密排列的，因此不会带来外部碎片。</p>
<h4 id="内存分页有什么缺点？"><a href="#内存分页有什么缺点？" class="headerlink" title="内存分页有什么缺点？"></a>内存分页有什么缺点？</h4><ol>
<li>分页用不满，很可能带来内部碎片</li>
<li>页表本身会非常大</li>
</ol>
<h4 id="多级页表是什么？"><a href="#多级页表是什么？" class="headerlink" title="多级页表是什么？"></a>多级页表是什么？</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com//mysql/other/19296e249b2240c29f9c52be70f611d5.png" alt="img"></p>
<p>原本是只有前四分之一的内存空间有被使用，但是页表仍然需要维持完整的映射（N项）</p>
<p>如果使用多级页表的话，那么后四分之三的内存空间的页表不需要进行分配，实际分配的空间是：</p>
<ul>
<li>4：一级页表的表项树木</li>
<li>1/4 N：二级页表表项数目</li>
</ul>
<p>即总共是1/4 N+4.大大降低了页表的大小</p>
<h4 id="TLB是什么？"><a href="#TLB是什么？" class="headerlink" title="TLB是什么？"></a>TLB是什么？</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com//mysql/other/a3cdf27646b24614a64cfc5d7ccffa35.png" alt="img"></p>
<p>虚拟地址到物理地址的转换比较花费时间，因此可以使用Cache（CPU与内存之间)保存使用频繁的页，这样就能降低到内存中查询页表的次数，大大降低了地址转换的时间花费。</p>
<h4 id="什么是段页式内存？"><a href="#什么是段页式内存？" class="headerlink" title="什么是段页式内存？"></a>什么是段页式内存？</h4><ul>
<li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</li>
<li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li>
</ul>
<p>地址 = 段号+页号+偏移量</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com//mysql/other/8904fb89ae0c49c4b0f2f7b5a0a7b099.png" alt="img"></p>
<p>段页式地址变换中要得到物理地址须经过三次内存访问：</p>
<ul>
<li>第一次访问段表，得到页表起始地址；</li>
<li>第二次访问页表，得到物理页号；</li>
<li>第三次将物理页号与页内位移组合，得到物理地址。</li>
</ul>
<h4 id="linux的内存管理"><a href="#linux的内存管理" class="headerlink" title="linux的内存管理"></a>linux的内存管理</h4><blockquote>
<p>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。</p>
</blockquote>
<p>但是，由于绝大多数硬件平台都不支持段机制，只支持分页机制，所以为了让 Linux 具有更好的可移植性，我们需要去掉段机制而只使用分页机制。但不幸的是，IA32规定段机制是不可禁止的，因此不可能绕过它直接给出线性地址空间的地址。万般无奈之下，Linux的设计人员干脆让段的基地址为0，而段的界限为4GB，这时任意给出一个偏移量，则等式为“0+偏移量=线性地址”，也就是说“偏移量＝线性地址”。</p>
<h4 id="linux虚拟地址空间是如何分布的？"><a href="#linux虚拟地址空间是如何分布的？" class="headerlink" title="linux虚拟地址空间是如何分布的？"></a>linux虚拟地址空间是如何分布的？</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com//mysql/other/3a6cb4e3f27241d3b09b4766bb0b1124-20230309234553726.png" alt="img"></p>
<ul>
<li><code>32</code> 位系统的内核空间占用 <code>1G</code>，位于最高处，剩下的 <code>3G</code> 是用户空间；</li>
<li><code>64</code> 位系统的内核空间和用户空间都是 <code>128T</code>，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。</li>
</ul>
<p>再来说说，内核空间与用户空间的区别：</p>
<ul>
<li>进程在用户态时，只能访问用户空间内存；</li>
<li>只有进入内核态后，才可以访问内核空间的内存；</li>
</ul>
<p>内核空间和用户空间的关系：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com//mysql/other/c88bda5db60029f3ea57e4306e7da936.png" alt="图片"></p>
<h4 id="用户空间的分布情况是什么样？"><a href="#用户空间的分布情况是什么样？" class="headerlink" title="用户空间的分布情况是什么样？"></a>用户空间的分布情况是什么样？</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="虚拟内存空间划分"></p>
<ul>
<li>代码段：二进制可执行代码</li>
<li>数据段：已经初始化的静态常量和全局变量（在编译时已确定）</li>
<li>BSS段：未初始化的静态变量和全局变量（在编译时已确定）</li>
<li>堆段：动态分配的内存</li>
<li>栈段：局部变量和函数调用的上下文</li>
<li>文件映射段：动态库、共享内存等</li>
</ul>
<h4 id="malloc如何分配内存？"><a href="#malloc如何分配内存？" class="headerlink" title="malloc如何分配内存？"></a>malloc如何分配内存？</h4><ul>
<li><p>使用<code>brk()</code>系统调用从堆分配内存</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/brk%E7%94%B3%E8%AF%B7.png" alt="img"></p>
</li>
<li><p>使用<code>mmap()</code>系统调用在文件映射区域分配内存</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/mmap%E7%94%B3%E8%AF%B7.png" alt="img"></p>
</li>
</ul>
<p>如果：</p>
<ol>
<li>分配内存小于128K，则通过<code>brk()</code>分配内存</li>
<li>分配内存大于128K，则通过<code>mmap()</code>分配内存</li>
</ol>
<h4 id="malloc分配的是物理内存吗？"><a href="#malloc分配的是物理内存吗？" class="headerlink" title="malloc分配的是物理内存吗？"></a>malloc分配的是物理内存吗？</h4><p>是虚拟内存</p>
<h4 id="malloc-1-分配多大的虚拟内存？"><a href="#malloc-1-分配多大的虚拟内存？" class="headerlink" title="malloc(1)分配多大的虚拟内存？"></a>malloc(1)分配多大的虚拟内存？</h4><p>不会按照用户输入进行分配，<strong>而是会预分配更大的空间作为内存池</strong></p>
<h4 id="使用free-的时候发生了什么？"><a href="#使用free-的时候发生了什么？" class="headerlink" title="使用free()的时候发生了什么？"></a>使用free()的时候发生了什么？</h4><ul>
<li>如果是<code>brk()</code>分配的内存，那么不会释放，而是缓存进内存池，当下次分配的时候可以复用</li>
<li>如果是<code>mmap()</code>分配的内存，那么使用<code>free()</code>就会释放内存</li>
</ul>
<h4 id="为什么不全部使用mmap来分配内存？"><a href="#为什么不全部使用mmap来分配内存？" class="headerlink" title="为什么不全部使用mmap来分配内存？"></a>为什么不全部使用mmap来分配内存？</h4><p>mmap分配内存的原理：</p>
<ol>
<li>建立进程虚拟地址空间与文件内容空间之间的映射</li>
<li><strong>而后第一次读写mmap映射的内存时，由于页表并未与物理内存映射，触发缺页异常</strong></li>
<li>缺页异常程序先根据要访问的偏移和大小从page cache中查询是否有该文件的缓存，如果找到就更新进程页表指向page cache那段物理内存</li>
<li>没找到就将文件从磁盘加载到内核page cache，然后再令进程的mmap虚拟地址的页表指向这段page cache中文件部分的物理内存</li>
</ol>
<p>所以结论是，内核会把文件读到page cache中。</p>
<p>因为mmap必然会导致缺页异常，因此不能全部使用mmap</p>
<h4 id="为什么不全部使用brk？"><a href="#为什么不全部使用brk？" class="headerlink" title="为什么不全部使用brk？"></a>为什么不全部使用brk？</h4><p>这样分配大空间的时候很容易出现内存碎片</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com//mysql/other/75edee0cb75450e7987a8a482b975bda.png" alt="图片"></p>
<h4 id="free函数只传入起始地址，为什么知道释放多大内存？"><a href="#free函数只传入起始地址，为什么知道释放多大内存？" class="headerlink" title="free函数只传入起始地址，为什么知道释放多大内存？"></a>free函数只传入起始地址，为什么知道释放多大内存？</h4><p> malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节</p>
<p><strong>这个多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小。</strong></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com//mysql/other/cb6e3ce4532ff0a6bfd60fe3e52a806e.png" alt="图片"></p>
<h4 id="内存分配的过程是怎么样的？"><a href="#内存分配的过程是怎么样的？" class="headerlink" title="内存分配的过程是怎么样的？"></a>内存分配的过程是怎么样的？</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com//mysql/other/2f61b0822b3c4a359f99770231981b07.png" alt="img"></p>
<h4 id="哪些内存可以被回收？"><a href="#哪些内存可以被回收？" class="headerlink" title="哪些内存可以被回收？"></a>哪些内存可以被回收？</h4><ul>
<li>文件页：可以直接被回收（除了脏页），因为磁盘中有备份</li>
<li>匿名页：不知道会不会再使用，因此一般不回收，而是放入swap区域</li>
</ul>
<h4 id="内存水位是什么概念？"><a href="#内存水位是什么概念？" class="headerlink" title="内存水位是什么概念？"></a>内存水位是什么概念？</h4><p>kswapd 会定期扫描内存的使用情况，根据剩余内存（pages_free）的情况来进行内存回收的工作。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com//mysql/other/166bc9f5b7c545d89f1e36ab8dd772cf.png" alt="img"></p>
<ul>
<li>图中绿色部分：如果剩余内存（pages_free）大于 页高阈值（pages_high），说明剩余内存是充足的；</li>
<li>图中蓝色部分：如果剩余内存（pages_free）在页高阈值（pages_high）和页低阈值（pages_low）之间，说明内存有一定压力，但还可以满足应用程序申请内存的请求；</li>
<li>图中橙色部分：如果剩余内存（pages_free）在页低阈值（pages_low）和页最小阈值（pages_min）之间，说明内存压力比较大，剩余内存不多了。<strong>这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值（pages_high）为止</strong>。虽然会触发内存回收，但是不会阻塞应用程序，因为两者关系是异步的。</li>
<li>图中红色部分：如果剩余内存（pages_free）小于页最小阈值（pages_min），说明用户可用内存都耗尽了，此时就会<strong>触发直接内存回收</strong>，这时应用程序就会被阻塞，因为两者关系是同步的。</li>
</ul>
<h4 id="如何防止一个进程被杀掉呢？"><a href="#如何防止一个进程被杀掉呢？" class="headerlink" title="如何防止一个进程被杀掉呢？"></a>如何防止一个进程被杀掉呢？</h4><p>在系统空闲内存不足的情况，进程申请了一个很大的内存，如果直接内存回收都无法回收出足够大的空闲内存，那么就会触发 OOM 机制，内核就会根据算法选择一个进程杀掉。</p>
<p>通过计算点数：</p>
<p>$$</p>
<p>$$</p>
<p>这个值越大越容易被杀掉</p>
<ul>
<li>可以降低<code>oom_score_adj</code>的值降低被杀的可能性</li>
<li>将其设置为<code>oom_score_adj=-1000</code>可以保证绝对不会被杀掉</li>
</ul>
<p>这个值存储在<code>/proc</code>文件中</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/2196/oom_score_adj</span></span><br><span class="line">0</span><br></pre></td></tr></tbody></table></figure></div>

<h4 id="在4GB物理内存的机器上申请8GB的内存会怎么样？"><a href="#在4GB物理内存的机器上申请8GB的内存会怎么样？" class="headerlink" title="在4GB物理内存的机器上申请8GB的内存会怎么样？"></a>在4GB物理内存的机器上申请8GB的内存会怎么样？</h4><ol>
<li>应用程序通过malloc分配内存的时候，实际申请的是虚拟内存，并不会分配物理内存</li>
<li>当应用读写这一块虚拟内存的时候，如果发现这一块虚拟内存没有映射到物理内存，那么就会产生<strong>缺页中断</strong>，进程会从用户态切换到内核态，并将缺页中断交给内核的Page Fault Handler处理<ol>
<li>如果还有空闲的物理内存，那么直接分配内存</li>
<li>如果没有则先进行回收内存的操作，如果回收之后还是没有足够的物理内存，则触发OOM</li>
</ol>
</li>
</ol>
<h4 id="什么是页面置换？"><a href="#什么是页面置换？" class="headerlink" title="什么是页面置换？"></a>什么是页面置换？</h4><p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p>
<blockquote>
<p><strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p>
</blockquote>
<p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p>
<h4 id="有哪些页面置换算法？"><a href="#有哪些页面置换算法？" class="headerlink" title="有哪些页面置换算法？"></a>有哪些页面置换算法？</h4><ul>
<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>
<li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>
<li><strong>LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li>
<li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>
<li><strong>时钟算法（CLOCK）</strong>：当某页被访问时，其访问位置为1，当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）</li>
</ul>
<h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><h4 id="有哪些磁盘调度算法"><a href="#有哪些磁盘调度算法" class="headerlink" title="有哪些磁盘调度算法"></a>有哪些磁盘调度算法</h4><ul>
<li>FIFO</li>
<li>最短寻道时间优先</li>
<li>扫描算法：磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，这就是扫描（Scan）算法。</li>
<li>循环扫描算法：循环扫描（<em>Circular Scan, CSCAN</em> ）规定：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且<strong>返回中途不处理任何请求</strong>，该算法的特点，就是<strong>磁道只响应一个方向上的请求</strong>。</li>
<li>LOOK算法：那针对 SCAN 算法的优化则叫 LOOK 算法，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中会响应请求</strong>。</li>
<li>CLOOK算法：而针 C-SCAN 算法的优化则叫 C-LOOK，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中不会响应请求</strong></li>
</ul>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><h4 id="文件系统的结构"><a href="#文件系统的结构" class="headerlink" title="文件系统的结构"></a>文件系统的结构</h4><p>数据块的位图是放在磁盘块里的，假设是放在一个块里，一个块 4K，每位表示一个数据块，共可以表示 <code>4 * 1024 * 8 = 2^15</code> 个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为 <code>2^15 * 4 * 1024 = 2^27</code> 个 byte，也就是 128M。</p>
<p>也就是说按照上面的结构，如果采用「一个块的位图 + 一系列的块」，外加「一个块的 inode 的位图 + 一系列的 inode 的结构」能表示的最大空间也就 128M，这太少了，现在很多文件都比这个大。</p>
<p>在 Linux 文件系统，把这个结构称为一个<strong>块组</strong>，那么有 N 多的块组，就能够表示 N 大的文件。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E5%9D%97%E7%BB%84.png" alt="img"></p>
<ul>
<li><em>超级块</em>，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。</li>
<li><em>块组描述符</em>，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。</li>
<li><em>数据位图和 inode 位图</em>， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。</li>
<li><em>inode 列表</em>，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。</li>
<li><em>数据块</em>，包含文件的有用数据。</li>
</ul>
<h3 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h3><h4 id="DMA的作用是什么？"><a href="#DMA的作用是什么？" class="headerlink" title="DMA的作用是什么？"></a>DMA的作用是什么？</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/DRM%20I_O%20%E8%BF%87%E7%A8%8B.png" alt="img"></p>
<ul>
<li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li>
<li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</li>
<li>DMA 进一步将 I/O 请求发送给磁盘；</li>
<li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li>
<li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li>
<li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li>
<li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li>
</ul>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：操作系统</li>
        <li>本文作者：Laiyikou</li>
        <li>创建时间：2023-04-17 21:50:33</li>
        <li>
            本文链接：https://lykdsb.github.io/2023/04/17/cao-zuo-xi-tong/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">#八股文</a>&nbsp;
                        </li>
                    
                        <li class="tag-item">
                            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">#操作系统</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/03/04/jdk-bing-fa-bao/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">JDK并发包</span>
                                    <span class="post-nav-item">下一篇</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title">操作系统</div>
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-text">中断</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD%EF%BC%9F"><span class="nav-text">什么是中断？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%B8%AD%E6%96%AD%EF%BC%9F"><span class="nav-text">什么是软中断？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-text">软中断有哪些类型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%AF%BC%E8%87%B4CPU%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%EF%BC%9F"><span class="nav-text">如果软中断导致CPU占用率过高？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-text">进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">进程与线程的区别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-text">进程有哪些状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">进程有哪些通信方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">多进程和多线程之间的区别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BE%88%E5%A4%9A%E5%9C%B0%E6%96%B9%E9%83%BD%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="nav-text">为什么chrome浏览器很多地方都使用进程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BC%BA%E7%82%B9%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">使用多进程的缺点有什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">并行和并发有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">同步和异步有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">进程的调度方式有哪些？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">必要条件是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-text">处理方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-text">为什么要有虚拟内存？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="nav-text">如何进行虚拟内存和物理内存之间的转换？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5%EF%BC%9F"><span class="nav-text">为什么要使用内存分段？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-text">内存分段有什么缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5%EF%BC%9F"><span class="nav-text">什么是内存分页？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-text">内存分页有什么缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">多级页表是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">TLB是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-text">什么是段页式内存？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linux%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">linux的内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linux%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E5%B8%83%E7%9A%84%EF%BC%9F"><span class="nav-text">linux虚拟地址空间是如何分布的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="nav-text">用户空间的分布情况是什么样？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-text">malloc如何分配内存？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc%E5%88%86%E9%85%8D%E7%9A%84%E6%98%AF%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%90%97%EF%BC%9F"><span class="nav-text">malloc分配的是物理内存吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc-1-%E5%88%86%E9%85%8D%E5%A4%9A%E5%A4%A7%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-text">malloc(1)分配多大的虚拟内存？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8free-%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">使用free()的时候发生了什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%A8%E9%83%A8%E4%BD%BF%E7%94%A8mmap%E6%9D%A5%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-text">为什么不全部使用mmap来分配内存？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%A8%E9%83%A8%E4%BD%BF%E7%94%A8brk%EF%BC%9F"><span class="nav-text">为什么不全部使用brk？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#free%E5%87%BD%E6%95%B0%E5%8F%AA%E4%BC%A0%E5%85%A5%E8%B5%B7%E5%A7%8B%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9F%A5%E9%81%93%E9%87%8A%E6%94%BE%E5%A4%9A%E5%A4%A7%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-text">free函数只传入起始地址，为什么知道释放多大内存？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">内存分配的过程是怎么样的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="nav-text">哪些内存可以被回收？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B0%B4%E4%BD%8D%E6%98%AF%E4%BB%80%E4%B9%88%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="nav-text">内存水位是什么概念？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%A2%AB%E6%9D%80%E6%8E%89%E5%91%A2%EF%BC%9F"><span class="nav-text">如何防止一个进程被杀掉呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A84GB%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E7%94%B3%E8%AF%B78GB%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="nav-text">在4GB物理内存的机器上申请8GB的内存会怎么样？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%EF%BC%9F"><span class="nav-text">什么是页面置换？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="nav-text">有哪些页面置换算法？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="nav-text">设备管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">有哪些磁盘调度算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-text">文件管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">文件系统的结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">网络系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DMA%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">DMA的作用是什么？</span></a></li></ol></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">Laiyikou</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a> 驱动</span>
                <br> 
            <span class="theme-version-container">主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v1.1.3</a>
        </div>
        
        
        
            <div id="start_time_div" style="display:none">
                2022/8/17 11:45:14
            </div>
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="unfolded-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="folded-tools-list">
        <li class="right-bottom-tools tool-toggle-show flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/menu-shrink.js"></script>

<script src="/js/tools/go-top-bottom.js"></script>

<script src="/js/tools/dark-light-toggle.js"></script>



    
<script src="/js/tools/local-search.js"></script>




    
<script src="/js/tools/code-block.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/layouts/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">



<div class="post-scripts pjax">
    
        
<script src="/js/tools/toc-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/layouts/toc.js"></script>

<script src="/js/plugins/tabs.js"></script>

    
    
        
<script src="/js/libs/mermaid.min.js"></script>

        
<script src="/js/plugins/mermaid.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>
