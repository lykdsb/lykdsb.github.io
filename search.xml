<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>forEach的实现方式</title>
    <url>/2022/09/08/foreach-de-shi-xian-fang-shi/</url>
    <content><![CDATA[<p>今天本来想要研究一下java其中的<code>Collection</code>的，但是当我看到java源码中的第一行时，我忽然发现我对于这个<code>Iterable</code>接口几乎毫无了解，虽然知道它与<code>forEach</code>的实现有关，但是过程是什么样的我还没有研究过。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h2><p>可以看到Iterable有三个部分<code>iterator()</code> <code>forEach()</code> <code>spliterator()</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; {</span><br><span class="line"></span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> {</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="built_in">this</span>) {</span><br><span class="line">            action.accept(t);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title function_">spliterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p>我们首先来看<code>Iterator</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; {</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> {</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>很明显这是一个接口。在这里需要注意一个知识点，就是<strong>接口中可以使用default方法老声明一个具体的方法</strong>。</p>
<p>我们可以在<code>AbstractList</code>中找到一个<code>Iterator</code>的实现类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> cursor != size();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="type">E</span> <span class="variable">next</span> <span class="operator">=</span> get(i);</span><br><span class="line">            lastRet = i;</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        } <span class="keyword">catch</span> (IndexOutOfBoundsException e) {</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            AbstractList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                cursor--;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        } <span class="keyword">catch</span> (IndexOutOfBoundsException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>有两个比较重要的量：</p>
<ul>
<li>cursor：Index of element to be returned by subsequent call to next.</li>
<li>lastRet：Index of element returned by most recent call to next or previous. Reset to -1 if this element is deleted by a call to remove.</li>
</ul>
<p>可以看到迭代器的访问方式如下</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line"><span class="type">E</span> <span class="variable">next</span> <span class="operator">=</span> get(i);</span><br><span class="line">lastRet = i;</span><br><span class="line">cursor = i + <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>也就是说迭代器的底层实现也是通过记录游标，然后通过Collection的get方法得到值。在获取值之后，浮标向后移动一位。重复这个操作并且加上判断<code>hasNext()</code>就完成了集合的遍历。而变量<code>lastRet</code>则标识迭代器最后一个返回的值，当我们需要删除掉已经遍历过的上一个值之后就能够直接删除掉<code>lastRet</code>指向的值。</p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>forEach</code>的代码中看起来没有提到<code>iterator</code>,但是通过查<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.14.2">资料</a>发现：</p>
<img src="/2022/09/08/foreach-de-shi-xian-fang-shi/forEach.png" class="" title="forEach">

<p>也就是说，当我们调用<code>for(T t:ts)</code>时，Java会自动编译成上面这一段代码，这两段代码是一致的。需要注意的是在这个过程中是<strong>不能使用<code>Collection</code>中的<code>remove</code>删除元素的</strong>。因为在iterator的遍历是依赖于集合的index的，如果直接通过Collection删除元素，那么会导致iterator中的index的混乱。</p>
<p>比如说：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>Alice</td>
<td>Bob</td>
<td>Cart</td>
<td>Diana</td>
<td>Eric</td>
</tr>
</tbody></table>
<p>当遍历到Bob的时候将其删除，此时<code>cursor</code>的值从1移动到2，但是由于Bob被删除，因此整个集合的值向前移动</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody><tr>
<td>Alice</td>
<td>Cart</td>
<td>Diana</td>
<td>Eric</td>
</tr>
</tbody></table>
<p>本来应该访问到Cart的，但是由于不恰当的删除导致访问到的是新的index为2的Diana。</p>
<p>为了避免这个问题，<code>Itr</code>使用了并发控制，在类初始化时，也就是第一次调用<code>iterator()</code>的时候，记录下当时的<code>modCount</code>。由于外部的修改会更改modCount值，因此在迭代器内部只需要检查<code>modCount</code>与<code>expectedModCount</code>是否相等即可知道是否发生了迭代器外部的改变。如果有发生则抛出<code>java.util.ConcurrentModificationException</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();iterator.hasNext();){</span><br><span class="line">   <span class="type">Integer</span> <span class="variable">next</span> <span class="operator">=</span>(Integer)iterator.next();</span><br><span class="line">   list.remove(next);</span><br><span class="line">}</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></tbody></table></figure>

<img src="/2022/09/08/foreach-de-shi-xian-fang-shi/Exception.png" class="" title="Exception">

<p>正确的方式应该是：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();iterator.hasNext();){</span><br><span class="line">   <span class="type">Integer</span> <span class="variable">next</span> <span class="operator">=</span>(Integer)iterator.next();</span><br><span class="line">   iterator.remove();</span><br><span class="line">}</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></tbody></table></figure>

<p>注意其中的<code>Consumer</code>用来传入函数引用，可以通过下面这种方式使用它</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></tbody></table></figure>

<p>然后<code>Consumer</code>通过<code>apply</code>函数将这个传入的方法应用到调用<code>apply</code>函数的变量中。</p>
<h3 id="spliterator"><a href="#spliterator" class="headerlink" title="spliterator()"></a>spliterator()</h3><p>这个方法主要用于集合的拆分。因为在多线程情况中，由于迭代器具有并发控制，只能够单线程运行，为了提升速度，可以将其进行拆分成多个部分，没个部分由一个线程来进行遍历，这样大大提高了遍历的速度。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/2022/09/09/san-shu-zhi-he/</url>
    <content><![CDATA[<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 0 且不重复的三元组。注意：<strong>答案中不可以包含重复的三元组。</strong></p>
<p><a href="https://leetcode.cn/problems/3sum">题目信息</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题目非常容易想出暴力虚幻遍历的方式，但是这种算法的时间复杂度达到了$O(N^3)$级别，基本上是不可接受的。从题目信息中的数据量$10^5$可以看出时间复杂度应该需要降到$O(N^2)$及以下。</p>
<p>应该有这种直觉，<strong>当需要进行两层循环进行遍历的时候，可以使用双指针的方法将时间复杂度降低到$O(N)$级别</strong>，因此我们这里也需要考虑使用双指针的方法解决问题。</p>
<p>但是仍然存在一个问题，就是双指针法必须在一个有序的数组中才能够使用。那么我们就可以使用$O(N\log N)$的排序方式对其进行排序，之后再使用双指针法进行搜索。由于排序之后的时间复杂度为$O(N^2)$，根据主定理可知排序并不会影响我们最终的时间复杂度。</p>
<p>我们可以得到这样一种思维</p>
<blockquote>
<p>当数组降维之后，遍历时间复杂度仍然大于$O(N\log N)$时，先进行排序是必然没有坏处的，在此基础上使用双指针法往往能够降低时间复杂度。</p>
</blockquote>
<p>在本题中先进行排序有两个好处</p>
<ul>
<li>能够使用双指针法进行遍历</li>
<li>能够非常方便的进行去重</li>
</ul>
<p>由于排序之后，相同的数都在一起，因此如果我们找到了满足条件的数之后，我们只需要挪动指针一直到一个不相同的数即可</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><strong>需要注意在求几数之和的时候需要考虑到溢出的问题</strong></p>
<p>解决方法主要有：</p>
<ul>
<li>如果计算 <code>a+b+c+d&lt;sum</code>会发生溢出的话，可以考虑将左边部分移到右边<code>a+b&lt;sum-c-d</code>，这样发生溢出的可能性会更低</li>
<li>同样也可以使用<code>(long)a+b+c+d&lt;sum</code>将和暂时转换为long可以避免发生溢出的情况。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      	<span class="comment">//进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>;i++){</span><br><span class="line">          	<span class="comment">//剪枝，如果最小的数都大于0，那么就没有必要计算了，和一定大于0</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">          	<span class="comment">//去重，如果两个数相同，那么结果在遍历前一个的时候已经得出了</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> j=i+<span class="number">1</span>,k=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;k){</span><br><span class="line">              	<span class="comment">//双指针遍历</span></span><br><span class="line">                <span class="keyword">if</span>((<span class="type">long</span>)nums[i]+nums[j]+nums[k]&gt;<span class="number">0</span>)k--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)nums[i]+nums[j]+nums[k]&lt;<span class="number">0</span>) j++;</span><br><span class="line">                <span class="keyword">else</span>{</span><br><span class="line">                    List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    cur.add(nums[i]);</span><br><span class="line">                    cur.add(nums[j]);</span><br><span class="line">                    cur.add(nums[k]);</span><br><span class="line">                    list.add(cur);</span><br><span class="line">										<span class="comment">//去重，将相同的j、k全部排除掉</span></span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[j+<span class="number">1</span>]==nums[j])j++;</span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[k-<span class="number">1</span>]==nums[k])k--;</span><br><span class="line">                    j++;</span><br><span class="line">                    k--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>下一个排列</title>
    <url>/2022/09/14/xia-yi-ge-pai-lie/</url>
    <content><![CDATA[<p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<p>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<p>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p>
<p>必须 <strong>原地 修改</strong>，只允许使用额外常数空间。</p>
<p><a href="https://leetcode.cn/problems/next-permutation/">题目</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><img src="/2022/09/14/xia-yi-ge-pai-lie/step1.png" class="" title="step1">

<p>我们可以随便使用一个排列<code>12385764</code>，他的下一个排列是<code>12386457</code>，经过多次实验观察，我们可以发现这样的规律：</p>
<ul>
<li>我们只需要操作的是从某一个数开始的后面的数</li>
</ul>
<p>那么如何找到这个数呢？</p>
<p>我们只需要确保只使用这个数及后面的部分就能够实现找到下一个更大的排列，那么我们需要找到一个数，<strong>这个数的后面一定有至少一个比他大的数</strong>。这样就能够保证在不使用前面的数的同时，生成一个更大的排列。我们只需要从右向左，一直比较相邻的数，只要左边的数比右边的数小，那么左边的数就是我们要找的数（因为由于我们刚刚的比较，右边的数是递减的，只要相邻的数比他大，那么右边一定有至少一个比它大的数）</p>
<img src="/2022/09/14/xia-yi-ge-pai-lie/step2.png" class="" title="step2">

<p>然后为了保证生成的是<strong>下一个</strong>排列，我们需要保证增加的值最小，因此我们只需要从后往前找到一个比这个数更大的数，对于<code>12385764</code>来说是6，我们进行交换就得到了<code>12386754</code></p>
<img src="/2022/09/14/xia-yi-ge-pai-lie/step3.png" class="" title="step3">

<img src="/2022/09/14/xia-yi-ge-pai-lie/step4.png" class="" title="step4">

<p>为了让这个排列最小，我们还需要保证6后面的数是升序排列，这是我们只需要将后面的数反转即可，因为后面的数一定是降序排列的。</p>
  <img src="/2022/09/14/xia-yi-ge-pai-lie/step5.png" class="" title="step5">

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[]nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>{</span><br><span class="line">        <span class="type">int</span> temp=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> len= nums.length;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[i+<span class="number">1</span>])<span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>){</span><br><span class="line">        	<span class="keyword">for</span>(j=len-<span class="number">1</span>;j&gt;i;j--){</span><br><span class="line">            	<span class="keyword">if</span>(nums[j]&gt;nums[i])<span class="keyword">break</span>;</span><br><span class="line">        	}</span><br><span class="line">        	swap(nums,i,j);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> m=i+<span class="number">1</span>;m&lt;=(len+i)/<span class="number">2</span>;m++){</span><br><span class="line">            </span><br><span class="line">            swap(nums,m,nums.length+i-m);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>只出现一次的数字</title>
    <url>/2022/10/18/zhi-chu-xian-yi-ci-de-shu-zi/</url>
    <content><![CDATA[<p>给你一个整数数组&nbsp;nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。</p>
<p>你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。<br><a href="https://leetcode.cn/problems/single-number-iii/">题目</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	可能是因为我之前做到过类似的题目，所以我可以非常清楚的记得这里存在对所有数字使用异或可以抵消全部的相同数字的方法。但是如何将这两个异或之后的数字进行合并我之前就没有考虑过了。在看题解的过程中我发现了一个思路：</p>
<ol>
<li>找到一个属性，使这两个数在这个属性上不一样</li>
<li>用这个属性将整个数组进行分类</li>
<li>在两个部分中分别使用异或去除重复的数（<strong>重复的数因为属性一样一定会被分入同一个部分</strong>）</li>
<li>得到这两个数</li>
</ol>
<p>那么使用什么属性能够保证这两个数在这个属性上不一样呢？</p>
<p><strong>这两个数的1的位数不一样</strong></p>
<p>那么为了方便，我们可以使用这两个数异或之后最低位的1来进行区分（因为异或之后要为1，在这个位上必定是一个1一个0）</p>
<p>那么问题就解决了！🎆</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">xor</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">            xor^=nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> xor&amp;(-xor);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            <span class="keyword">if</span>((nums[i]&amp;mask)==<span class="number">0</span>){</span><br><span class="line">                res[<span class="number">1</span>]^=nums[i];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                res[<span class="number">0</span>]^=nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="一些值得注意的地方"><a href="#一些值得注意的地方" class="headerlink" title="一些值得注意的地方"></a>一些值得注意的地方</h2><p>要获得最后一位1有一个很巧妙的方式：<br>$$<br>Mask=n\and(-n)<br>$$<br>首先在计算机中二进制取负是取反再加一。比如a的二进制是 00010000，取反就是11101111，加1就是11110000。前面?的部分是和原来a相反的，相与必然都是0，所以最后整体相与的结果就是00010000。</p>
<p>另外，java中计算<code>(nums[i]&amp;mask)==0</code>的时候需要加括号，<strong>因为==的优先级高于&amp;</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>合并k个升序链表</title>
    <url>/2022/09/09/he-bing-k-ge-sheng-xu-lian-biao/</url>
    <content><![CDATA[<p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">题目</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实这里很容易就会想到归并排序中，两个有序数组合并的过程，这里使用的也是相同的思想。但是需要注意的是这里需要合并的是多个链表，也就是说每一次要进行K次的比较，如果采用这种方式的话，时间复杂度为$O(KN)$。</p>
<p>但是如果我们在这里使用<strong>堆</strong>就能比较容易得解决这个问题。我们建立一个堆，根据链表所指节点的值来进行比较，每次挑选出堆顶的一个节点，选出后将这个节点的值用于建立新链表，同时将这个节点的下一个节点放入堆中，并进行调整，重复直到所有链表节点都已经遍历。</p>
<p>我们可以将这道题的思路总结成下面这样：</p>
<blockquote>
<p>如果我们要在一组数中挑选出最小的或者最大的一个，而且这组数是动态变化的，那么我们一般优先考虑使用堆/优先队列来解决这个问题</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> {</span><br><span class="line">        <span class="keyword">if</span>(lists.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt;heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a.val-b.val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lists.length;i++){</span><br><span class="line">            <span class="keyword">if</span>(lists[i]!=<span class="literal">null</span>)heap.offer(lists[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(!heap.isEmpty()){</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">peek</span> <span class="operator">=</span> heap.poll();</span><br><span class="line">            <span class="keyword">if</span>(peek.next!=<span class="literal">null</span>)</span><br><span class="line">                heap.offer(peek.next);</span><br><span class="line">            cur.next=<span class="keyword">new</span> <span class="title class_">ListNode</span>(peek.val);</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转链表</title>
    <url>/2022/10/21/xuan-zhuan-lian-biao/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标记接口</title>
    <url>/2022/09/09/biao-ji-jie-kou/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>疲惫与困倦</title>
    <url>/2022/09/07/pi-bei-yu-kun-juan/</url>
    <content><![CDATA[<p>此刻我站在床边打下这一段文字，用这种方式克服仿佛在高楼边缘向下看想要跳下去一般的困倦。立交桥上过往的车流发出低沉的声音，与远处维港中货轮发出的汽笛声纠结在一起，好像形成了共振一般放大了我思想的昏沉。要是能倒下去一睡不醒就好了，没有Peer Pressure、没有内卷、没有压迫、没有绝望，只有充满爱的留着奶与蜜的梦乡。“你恨它，但是你摆脱不了它”不知何方而来的这样的嘲讽更加深了神（也许有吧）的这种设计的滑稽性。我挥舞着利刃，想要将它刺穿，可是我从未击中，也许疲倦从此而来吧。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>香港札记（一）</title>
    <url>/2022/09/07/xiang-gang-zha-ji-yi/</url>
    <content><![CDATA[<p>不知不觉已经在香港已经过了快两个星期，在几乎无法感受到的时间的流逝中，我逐渐习惯了在香港的生活。有人说香港人的生活节奏很快，不过从我居住的西营盘周围来看倒并不见得。这里的居民几乎都是老年人和学生，不需要赶很早的地铁，也不像大陆的互联网社畜晚上十点十一点才能够回家，我总是能看到在西边街和正街的陡坡上拍摄如同金鱼一般颜色的夕阳，也能看到中年大叔在顺德烧味店里熟练的说“唔该，半斤叉烧”，然后悠然而去。</p>
<p>不管是什么店铺，在香港十点钟之前总是要关门的。如果下课时间正好接近十点的我走进店铺中，店员会在我挑选东西的时候，忙着把店中的灯关掉、整理货物，甚至半带上卷帘门，不知是为了督促我快一点还是就是为了能在我结账完之后马上下班（好像没什么区别），经常破坏我购物的兴致，让我无心挑选，随便在去往收银台的路径上拿几件必需品，甚至连价格都没看清楚，难怪华仔会有“今時今日咁既服務態度”的宣传片。</p>
<p>往往下课回家，门口的保安都不在了，令人不禁疑惑最需要保安的时候不应该就是晚上吗？为什么保安晚上能下班呢？而且他中午也在保安室的玻璃窗上挂一个“午膳中”，然后就不知踪影，真想知道他们一天上多久的班，能领多少钱。不过保安人还是挺不错的，他长得有点像火云邪神，不过头发要多几根，笑起来的时候简直一模一样，记得第一天来的时候，他先用粤语和我讲话，我只能用非常蹩脚的粤语回话，他发现我不是本地人之后，就用英语来问我，很惭愧我的口语水平还不如保安，只能嗯嗯啊啊用普通话回复他。见的多了之后，我们也开始互相说“早晨”了，只是有碍于我的语言能力不行，到现在也只会说“早晨”，只能说毫无进步。</p>
<p>不过粤语倒并没有成为在香港生活的障碍，记得第一次走进惠康的时候，结账时憋的脸红脖子粗，即便粤语能力能大致应对这个场景，但是没有自信的人是在母语者面前是说不出口的。最后配合手势才说清楚要两个塑料袋。待了一段时间之后，我发现香港大部分人都会讲普通话，甚至我之前以为必定只会说粤语的钱大妈的中年收银员都能说一口标准的普通话，从此我和香港人打交道一般先说粤语，等到说到第三句的时候我一般就听不懂了，这时候就能够切换成普通话，既表现了我对他们文化的尊重，又锻炼了我的粤语水平（也许吧），还不影响交流。这大概也算融入进去了吧。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>香港</tag>
      </tags>
  </entry>
</search>
